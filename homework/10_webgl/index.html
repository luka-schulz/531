<!DOCTYPE>
<html lang="en-US">
  <head>
    <title>Open GL</title>
    
    <script id="vertex" type="x-shader/x-vertex"> 
      attribute vec2 aPosition; 
      attribute vec2 aTextureCoord; 

      varying vec2 vTexCoord; 

      void main() { 
        vTexCoord = aTextureCoord; 
        gl_Position = vec4( aPosition, 0, 1 );
      } 
    </script>
    
    <script id="fragment" type="x-shader/x-fragment">
      precision mediump float; 
      varying vec2 vTexCoord;   
      uniform sampler2D uSampler; 

      void main() {
        gl_FragColor = texture2D(uSampler,vec2(vTexCoord.s, vTexCoord.t));
      } 
    </script>
    
    <script>
      let gl, textureCtx, canvas, textureCanvas,
          buffer, vertexSource, vertexShader,
          fragmentSource, fragmentShader,
          program;
      
      window.onload = function() {
        
        canvas = document.getElementById( "gl" );
        canvas.width = canvas.height = 256;
        gl = canvas.getContext( "webgl" );
        
        textureCavnas = document.getElementById( "texture" );
        textureCavnas.width = textureCavnas.height = 256;
        textureCtx = textureCavnas.getContext( "2d" );
        
        // define drawing area of canvas. bottom corner, width / height 
        gl.viewport( 0, 0, gl.drawingBufferWidth*2, gl.drawingBufferHeight*2 );   
        // create a buffer object to store vertices 
        buffer = gl.createBuffer();

        // point buffer at graphic context's ARRAY_BUFFER 
        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

        let triangles = new Float32Array( [-1, -1,  1, -1,  -1, 1,  -1, 1,  1, -1, 1, 1 ] );

        // initialize memory for buffer and populate it. Give  
        // WebGL hint contents will not change dynamically. 
        gl.bufferData( gl.ARRAY_BUFFER, triangles, gl.STATIC_DRAW );
        
        // create vertex shader 
        vertexSource = document.getElementById( "vertex" ).text;
        vertexShader = gl.createShader( gl.VERTEX_SHADER );
        gl.shaderSource( vertexShader, vertexSource );
        gl.compileShader( vertexShader );

        // create fragment shader 
        fragmentSource = document.getElementById( "fragment" ).text;
        fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
        gl.shaderSource( fragmentShader, fragmentSource );  gl.compileShader( fragmentShader );

        // create shader program 
        program = gl.createProgram();
        gl.attachShader( program, vertexShader );
        gl.attachShader( program, fragmentShader );
        gl.linkProgram( program );
        gl.useProgram( program );
        
        var position = gl.getAttribLocation( program, "aPosition" );
        gl.enableVertexAttribArray( position );
        gl.vertexAttribPointer( position, 2, gl.FLOAT, false, 0,0 );
        
        program.textureCoordAttribute = gl.getAttribLocation( program, "aTextureCoord" );
        gl.enableVertexAttribArray( program.textureCoordAttribute );
        gl.vertexAttribPointer( program.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0 ); 
        
        // the sampler will automatically pass in the bound texture
        program.samplerUniform = gl.getUniformLocation( program, "uSampler" );
        gl.uniform1i( program.samplerUniform, 0 );
        
        texture = gl.createTexture();
        
        render();
      }

      function getTexture() { 
        // canvas draws with the upper-left hand corner as {0,0}, while WebGL
        // draws with the lower-left corner at {0,0}. Therefore we need to flip
        // the y-axis when we read in our canvas pixel data.
        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true ); 

        gl.bindTexture( gl.TEXTURE_2D, texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas );

        // use linear interpolation to generate sub-pixel data
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );
      }

      function webglSetup() { 
        // sets default background color
        gl.clearColor( 1.0, 1.0, 1.0, 1.0 );

        // clear color buffer 
        gl.clear( gl.COLOR_BUFFER_BIT );

        gl.activeTexture( gl.TEXTURE0 );
      }

      function render() { 
        window.requestAnimationFrame( render, canvas );

        webglSetup();

        // this is your draw method... for example, draw cellular automata etc
        // draw something interesting here! 
        canvasDraw();

        getTexture();

        // draw triangles using the array buffer from index 0 to 6 (6 is count)
        // and using the bound texture 
        gl.drawArrays( gl.TRIANGLES, 0, 6 );
      }

      function canvasDraw() {
        textureCtx.fill = "black";
        textureCtx.fillRect( 0, 0, 256, 256 );
      }
      
    </script>
  </head>
  
  <body>
    <canvas id="gl"></canvas>
    <canvas id="texture"></canvas>
  </body>
</html>